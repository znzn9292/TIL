# 1. 코틀린에서 변수와 타입, 연산자를 다루는 방법

## 1.3. 코틀린에서 Type을 다루는 방법

### 기본 타입

#### Kotlin
```kotlin
val number1 = 3 // Int
val number2 = 3L // Long
val number3 = 3.0f // Float
val number4 = 3.0 // Double 
```
* 코틀린에서는 선언된 기본값을 보고 타입을 추론한다.

#### Java
```java
int number1 = 3
long number2 = number1; // 정상
```

#### Kotlin
```kotlin
val number1 = 3
val number2: Long = number1; // 컴파일 에러, Type mismatch
val number2: Long = number1.toLong() // 정상
```
* **자바**에서 `int` 타입의 값이 `long` 타입으로 **암시적으로** 변경
* **코틀린**에서는 `.toLong()`, `.toDouble()`, `.toFloat()` 등 기본 타입간의 변환은 **명시적으로** 이루어져야 한다.

### 타입 캐스팅

#### Java
```java
public static void printAgeIfPerson(Object obj) {
    if (obj instanceof Person) {
        Person person = (Person) obj;
        System.out.println(person.getAge());
    }
}
```

#### Kotlin
```kotlin
fun printAgeIfPerson(obj: Any) {
    if(obj is Person) {
        val person = obj as Person
        println(person.age)
    }
}
```
||Java|Kotlin|
|--|--|--|
|타입 비교|`instanceof`|`is`|
|타입 비교 부정|`!(obj instanceof Person)`|`!is`|
|타입 캐스팅|`(Person) obj`|`as Person`|

### 특이한 타입 3가지 - Any
* 자바의 `Object` 역할 (모든 객체의 최상위 타입)
* 모든 Primitive Type의 최상위 타입
* Any 자체로는 null을 포함할 수 없어 null을 포함하고 싶다면, `Any?`로 표현
* Any에 `equals` / `hashCode` / `toString` 존재.

### 특이한 타입 3가지 - Unit
* Unit은 자바의 `void` 역할
* `void`와 다르게 Unit은 그 자체로 타입 인자로 사용 가능
* 함수형 프로그래밍에서 Unit은 단 하나의 인스턴스만 갖는 타입을 의미. 즉, 코틀린의 Unit은 실제 존재하는 타입이라는 것을 표현

### 특이한 타입 3가지 - Nothing
* Nothing은 함수가 정상적으로 끝나지 않았다는 사실을 표헌하는 역할
* 무조건 예외를 반환하는 함수 / 무한 루프 함수 등

### String interpolation / String indexing

#### Java
```java
Person person = new Person("정선환", 100);
String log = String.format("사람의 이름은 %s이고 나이는 %s세 입니다.", person.getName(), person.getAge());
```
#### Kotlin
```kotlin
val person = Person("정선환", 100)
val log = "사람의 이름은 ${person.name}이고 나이는 ${person.age}세 입니다."
```

> `${}`을 변수로 사용 시 괄호 생략이 가능하지만 괄호는 넣어 사용 하는 것이 **가독성**, **일괄변환**, **정규식 활용** 측면에서 좋다.
